<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>python on Dev Blog</title>
    <link>https://blog.aaronnotes.com/tags/python/</link>
    <description>Recent content in python on Dev Blog</description>
    <image>
      <title>Dev Blog</title>
      <url>https://cdn.jsdelivr.net/gh/lijqhs/cdn@1.6/img/icons/rocket-andy-hermawan-unsplash.jpg</url>
      <link>https://cdn.jsdelivr.net/gh/lijqhs/cdn@1.6/img/icons/rocket-andy-hermawan-unsplash.jpg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 05 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.aaronnotes.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>functools</title>
      <link>https://blog.aaronnotes.com/posts/python/functools/</link>
      <pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/functools/</guid>
      <description>functools provides a range of features that can greatly simplify your code and make it more efficient. The functools module is part of the Python standard library and provides higher-order functions, decorators, and other utilities for working with functions.
functools.partial: Partial Function Application Partial function application is a technique where you create a new function by fixing certain arguments of an existing function, allowing you to provide only the remaining arguments when calling the new function.</description>
    </item>
    
    <item>
      <title>Overriding vs. Overloading</title>
      <link>https://blog.aaronnotes.com/posts/python/overriding-vs-overloading/</link>
      <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/overriding-vs-overloading/</guid>
      <description>Both overriding and overloading are concepts in object-oriented programming that allow you to define methods with the same name but different behavior. However, they differ in their implementation and purpose.
Overriding Overriding is a mechanism by which a subclass can provide a different implementation of a method that is already defined in its superclass. When a method is overridden, the subclass&amp;rsquo;s implementation takes precedence over the superclass&amp;rsquo;s implementation, allowing you to customize the behavior of the method for the specific subclass.</description>
    </item>
    
    <item>
      <title>Namedtuple</title>
      <link>https://blog.aaronnotes.com/posts/python/namedtuple/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/namedtuple/</guid>
      <description>The namedtuple function is a factory function from the collections module in Python that creates a new class-like object that behaves like a tuple, but with named fields. Here are some cases where you might consider using namedtuple:
  Improved readability: If you have a collection of records or objects that have a fixed set of attributes, using a namedtuple can make your code more readable by giving names to the fields instead of relying on integer indices.</description>
    </item>
    
    <item>
      <title>Name Mangling</title>
      <link>https://blog.aaronnotes.com/posts/python/name-mangling/</link>
      <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/name-mangling/</guid>
      <description>Name mangling is a feature in Python that is used to avoid naming conflicts in class hierarchies by adding a prefix to the name of a class member that starts with two underscores, but does not end with more than one underscore.
When a member name is prefixed with two underscores, Python automatically rewrites the name in a way that makes it harder to access the member from outside the class.</description>
    </item>
    
    <item>
      <title>Monkey Patching</title>
      <link>https://blog.aaronnotes.com/posts/python/monkey-patching/</link>
      <pubDate>Sun, 09 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/monkey-patching/</guid>
      <description>In Python programming, monkey patching refers to the practice of modifying or extending the behavior of a module or object at runtime. This technique allows developers to change the behavior of existing code without modifying the original source code. While monkey patching can be a powerful tool, it can also be dangerous if used improperly.
What is Monkey Patching? Monkey patching is a technique that allows developers to dynamically modify the behavior of an object or module at runtime.</description>
    </item>
    
    <item>
      <title>Itertools</title>
      <link>https://blog.aaronnotes.com/posts/python/itertools/</link>
      <pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/itertools/</guid>
      <description>itertools is a powerful Python library that provides a collection of tools for working with iterators and iterable objects. The library is part of the Python standard library, which means that it comes pre-installed with every Python distribution. itertools provides a suite of functions that can help you manipulate and iterate over iterable objects in a more efficient and concise manner. In this article, we&amp;rsquo;ll explore some of the most useful functions in itertools and give some funny examples to help you understand when to use them.</description>
    </item>
    
    <item>
      <title>Generator</title>
      <link>https://blog.aaronnotes.com/posts/python/generator/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/generator/</guid>
      <description>In Python, a generator is a special type of function that can be used to create iterable sequences of values on-the-fly. Unlike regular functions, which compute and return a value immediately, generators can generate a sequence of values over time, using the yield keyword.
Example: The following fib function is a generator function that generates a sequence of Fibonacci numbers up to a given limit index n.
def fib(n): a = [0, 1] i = 0 while i &amp;lt;= n: yield a[i%2] a[i%2] = a[0] + a[1] i += 1  The yield keyword is used to return each generated Fibonacci number as it is generated, which makes the function a generator.</description>
    </item>
    
    <item>
      <title>Duck Typing</title>
      <link>https://blog.aaronnotes.com/posts/python/duck-typing/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/duck-typing/</guid>
      <description>Duck typing is a concept in dynamic programming languages like Python, where the type of an object is determined not by its class name, but by its behavior or the methods and attributes it defines. The term &amp;ldquo;duck typing&amp;rdquo; comes from the phrase &amp;ldquo;if it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.&amp;rdquo;
In Python, duck typing means that an object&amp;rsquo;s suitability for a given task is determined by the presence of specific methods or attributes, rather than its type.</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://blog.aaronnotes.com/posts/python/dependency-injection/</link>
      <pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/dependency-injection/</guid>
      <description>Dependency injection is a design pattern commonly used in software engineering that allows for the separation of concerns and promotes code reusability. It is a technique that enables the creation of loosely coupled code, which can be easily tested, maintained, and extended.
What is Dependency Injection? Dependency injection is a design pattern that allows for the separation of concerns between different parts of a program or system. In dependency injection, the dependencies required by a component or module are injected into it at runtime, rather than being hardcoded into the component or module.</description>
    </item>
    
    <item>
      <title>Singleton with Decorator</title>
      <link>https://blog.aaronnotes.com/posts/python/singleton-with-decorator/</link>
      <pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/singleton-with-decorator/</guid>
      <description>In Python, a singleton is a design pattern that restricts the instantiation of a class to a single object. A singleton class ensures that only one instance of the class is created and provides a global point of access to that instance.
One way to implement a singleton in Python is to use a decorator. Here&amp;rsquo;s an example:
def singleton(cls): instances = {} def get_instance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return get_instance @singleton class MyClass: def __init__(self, x): self.</description>
    </item>
    
    <item>
      <title>Comprehensions</title>
      <link>https://blog.aaronnotes.com/posts/python/comprehensions/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/comprehensions/</guid>
      <description>In Python, there are several types of comprehensions that can be used to create new data structures from existing ones:
list comprehension A list comprehension is a concise way to create a new list by iterating over an existing iterable and applying a transformation or filtering condition to each element. Here&amp;rsquo;s an example:
my_list = [1, 2, 3, 4, 5] squared_list = [x*x for x in my_list] print(squared_list) # Output: [1, 4, 9, 16, 25]  In this example, the list comprehension [x*x for x in my_list] creates a new list by squaring each element of my_list.</description>
    </item>
    
    <item>
      <title>Arguments</title>
      <link>https://blog.aaronnotes.com/posts/python/arguments/</link>
      <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/arguments/</guid>
      <description>In Python, there are several ways to pass arguments to a function, including positional arguments, keyword arguments, default arguments, variable-length argument lists (*args), and variable-length keyword argument dictionaries (**kwargs). The choice of argument passing method depends on the specific requirements of the function and the nature of the data being passed.
Here&amp;rsquo;s a brief overview of the different argument passing methods in Python:
  Positional arguments: Positional arguments are passed to a function based on their position in the argument list.</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://blog.aaronnotes.com/posts/python/array/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.aaronnotes.com/posts/python/array/</guid>
      <description>In Python, an array is a data structure that stores a collection of elements of the same data type. Unlike lists, which can contain elements of different data types, arrays can only contain elements of a single data type, such as integers, floats, or characters.
Python supports two types of arrays: arrays provided by the built-in array module and arrays provided by the numpy module.
built-in array module The array module provides a simple way to create and manipulate arrays of primitive data types, such as integers, floats, and characters.</description>
    </item>
    
  </channel>
</rss>
